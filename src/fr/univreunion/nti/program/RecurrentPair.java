/*
 * Copyright 2022 Etienne Payet <etienne.payet at univ-reunion.fr>
 * 
 * This file is part of NTI.
 * 
 * NTI is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * NTI is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with NTI. If not, see <http://www.gnu.org/licenses/>.
 */

package fr.univreunion.nti.program;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;

import fr.univreunion.nti.term.Function;
import fr.univreunion.nti.term.FunctionSymbol;
import fr.univreunion.nti.term.Hole;
import fr.univreunion.nti.term.Term;

/**
 * A recurrent pair for proving the existence of a binary loop
 * (see Def. 3.12 of [Payet, JAR'23]).
 * 
 * @author <A HREF="mailto:etienne.payet@univ-reunion.fr">Etienne Payet</A>
 */

public class RecurrentPair {

	/**
	 * The left-hand side of the rule R1
	 * of this recurrent pair.
	 */
	private final Function l1;

	/**
	 * The right-hand side of the rule R1
	 * of this recurrent pair.
	 */
	private final Function r1;


	/**
	 * The left-hand side of the rule R2
	 * of this recurrent pair.
	 */
	private final Function l2;

	/**
	 * The right-hand side of the rule R2
	 * of this recurrent pair.
	 */
	private final Function r2;

	/**
	 * The ground context C of this recurrent pair.
	 */
	private final Term C;

	/**
	 * The ground term t of this recurrent pair.
	 */
	private final Term t;

	/**
	 * The position of the increasing argument
	 * of this recurrent pair.
	 */
	private final int i;

	/**
	 * The position of the decreasing argument
	 * of this recurrent pair.
	 */
	private final int j;

	/**
	 * A non-terminating term generated by
	 * this recurrent pair.
	 */
	private final Function nonterminating;


	/**
	 * Static factory method. Tries to build a recurrent
	 * pair from the provided elements.
	 * 
	 * If a recurrent pair cannot be built then
	 * <code>null</code> is returned.
	 * 
	 * @param l the lhs of the first rule
	 * @param r the rhs of the first rule
	 * @param u the lhs of the second rule
	 * @param v the rhs of the second rule
	 * @return a recurrent pair, or <code>null</code>
	 */
	public synchronized static RecurrentPair getInstance(
			Function l, Term r, Function u, Term v) {

		if (r.isVariable() || v.isVariable() ||
				!r.hasSameStructureAs(u) ||
				!v.hasSameStructureAs(l))
			return null;

		boolean b1 = r.hasSameStructureAs(l);
		boolean b2 = v.hasSameStructureAs(u);

		if (!(b1 || b2)) return null;

		// Here, l, r, u and v necessarily have the form f(...)
		// for the same function symbol f.

		RecurrentPair result = null;
		if (b1)
			result = buildRecPair(l, (Function) r, u, (Function) v);
		if (result == null && b2)
			result = buildRecPair(u, (Function) v, l, (Function) r);

		return result;
	}

	/**
	 * Tries to build a recurrent pair from the
	 * provided elements. If a recurrent pair
	 * cannot be built then <code>null</code>
	 * is returned.
	 * 
	 * The provided terms necessarily have the
	 * form f(...) for the same function symbol f.
	 * 
	 * Moreover, <code>l1<code> unifies with a 
	 * renamed apart variant of <code>r1<code>,
	 * <code>r1<code> unifies with a renamed
	 * apart variant of <code>l2<code> and
	 * <code>r2<code> unifies with a 
	 * renamed apart variant of <code>l1<code>.
	 * 
	 * @param l1 the lhs of the rule R1 of the
	 * built recurrent pair
	 * @param r1 the rhs of the rule R1 of the
	 * built recurrent pair
	 * @param l2 the lhs of the rule R2 of the
	 * built recurrent pair
	 * @param r2 the rhs of the rule R2 of the
	 * built recurrent pair
	 * @return a recurrent pair, or <code>null</code>
	 */
	private synchronized static RecurrentPair buildRecPair(
			Function l1, Function r1, Function l2, Function r2) {
		
		// We flatten l1 and r1 (i.e., make each subterm the
		// only element of its class and be its own schema).
		Map<Term, Term> copies = new HashMap<Term, Term>();
		l1 = (Function) l1.deepCopy(copies);
		r1 = (Function) r1.deepCopy(copies);

		// We also flatten l2 and r2.
		copies = new HashMap<Term, Term>();
		l2 = (Function) l2.deepCopy(copies);
		r2 = (Function) r2.deepCopy(copies);

		// Here, l1, r1, l2 and r2 necessarily have the
		// form f(...) for the same function symbol f.

		// Now, we try to compute C, t, i and j.

		// The symbol f and its arity.
		FunctionSymbol f = l1.getRootSymbol();
		int n = f.getArity();

		// We identify the position i.
		for (int i = 0; i < n; i++) {
			// First, we check whether l1 = f(...,x1,...) and
			// l2 = f(...,x2,...) where x1 and x2 are variables
			// located at position i and occur only at that
			// position in l1, rr1 and l2.
			Term x1 = l1.getChild(i), x2 = l2.getChild(i);
			if (x1.isVariable() && x2.isVariable() &&
					occursOnlyAt(x1, l1,  i, -1, n) &&
					occursOnlyAt(x1, r1, i, -1, n) &&
					occursOnlyAt(x2, l2,  i, -1, n)) {

				// We identify the position j.
				for (int j = 0; j < n; j++)
					if (j != i) {
						Term y1 = r1.getChild(j);
						Term t = l2.getChild(j);

						if (x1 != y1 && y1.isVariable() &&
								occursOnlyAt(y1, l1,  -1, j, n) &&
								occursOnlyAt(y1, r1, -1, j, n) &&
								occursOnlyAt(x2, r2, i, j, n)  && 
								t.isGround()) {

							Term s = r1.getChild(i);
							Term t1 = r2.getChild(i), t2 = r2.getChild(j);

							Term C = null;
							// 0x25A1 is the UFT-16 encoding of
							// the white square character.
							Hole square = new Hole("" + '\u25A1');

							boolean cond3;
							if (cond3 = (t2 == x2))
								// Condition (3) of Def. 3.12 of
								// [Payet, JAR'23].
								C = contextFrom(
										new Term[] {l1.getChild(j), s, t1},
										new Term[] {y1, x1, t},
										square);
							
							else if (s == x1 && t1.deepEquals(t2))
								// Condition (4) of Def. 3.12 of
								// [Payet, JAR'23].
								C = contextFrom(
										new Term[] {l1.getChild(j), t2},
										new Term[] {y1, x2},
										square);

							if (C != null && C != square && C.getVariables().size() == 1) {
								// Here, C is a ground context (i.e., its only
								// variable is the hole) and is not the hole.

								// We build a non-terminating term generated
								// by the recurrent pair.
								// The arguments of the non-terminating term:
								LinkedList<Term> arguments = new LinkedList<Term>();

								for (int k = 0; k < n; k++)
									if (k == i) {
										// If cond. 3 holds then t1 = c[t].
										if (cond3) arguments.add(t1);
										else arguments.add(t);
									}
									else if (k == j) arguments.add(t);
									else {
										Term l1_k = l1.getChild(k);
										if (!(l1_k.unifyWith(r1.getChild(k)) &&
												l1_k.unifyWith(l2.getChild(k)) &&
												l1_k.unifyWith(r2.getChild(k))))
											// If a non-terminating term cannot be built
											// then we stop because another i or another j
											// will not work. Indeed, at that point, we have
											// l1_j = c[y] and r1_j = y, i.e., l1_j does not
											// unify with r1_j. We have something similar for i.
											return null;
										arguments.add(l1_k);
									}

								// Finally, if a non-terminating term could be built
								// then we stop and return a recurrent pair. 
								return new RecurrentPair(l1, r1, l2, r2,
										C, t, i, j, new Function(f, arguments));
							}

						}
					}
			}
		}

		return null;
	}

	/**
	 * Checks whether the given term <code>x</code>
	 * occurs only at the given positions <code>i</code>
	 * and <code>j</code> of the given term <code>s</code>.
	 * 
	 * @param x a term whose presence is to be tested
	 * @param s a term where the check occurs
	 * @param i a position at which the presence is allowed
	 * @param j another position at which the presence is allowed
	 * @param n the arity of the function symbol of <code>s</code>
	 * @return <code>true</code> iff <code>x</code>
	 * occurs only at positions <code>i</code>
	 * and <code>j</code> of <code>s</code>
	 */
	private synchronized static boolean occursOnlyAt(
			Term x, Function s, int i, int j, int n) {

		for (int k = 0; k < n; k++)
			if (k != i && k != j && s.getChild(k).contains(x))
				return false;

		return true;
	}

	/**
	 * Tries to build a common context from the
	 * provided terms.
	 * 
	 * More precisely, checks whether 
	 * <code>outer[k] = c[inner[k]]</code>
	 * for all <code>k</code>, where <code>c</code>
	 * is a common context.
	 * 
	 * @param outer the outer terms from which a
	 * context is built
	 * @param inner the inner terms from which a
	 * context is built
	 * @param square the hole to be used while
	 * building the context
	 * @return a context, or <code>null</code> if
	 * no context could be built from the provided
	 * terms
	 */
	private synchronized static Term contextFrom(
			Term[] outer, Term[] inner, Hole square) {

		int n = outer.length;

		// First, we check whether we have to
		// return the hole.
		if (outer[0].deepEquals(inner[0])) {
			for (int k = 1; k < n; k++)
				if (!outer[k].deepEquals(inner[k])) return null;
			return square;
		}

		// From here, the outer terms have to be functions.
		if (outer[0] instanceof Function) {
			FunctionSymbol f = outer[0].getRootSymbol();
			// All the other outer terms must have the form f(...).
			for (int l = 1; l < n; l++)
				if (outer[l].getRootSymbol() != f) return null;

			int a = f.getArity();
			LinkedList<Term> arguments = new LinkedList<Term>();
			for (int k = 0; k < a; k++) {
				Term[] outer_k = new Term[n];
				for (int l = 0; l < n; l++)
					outer_k[l] = outer[l].get(k);
				Term C_k;
				if ((C_k = contextFrom(outer_k, inner, square)) == null)
					return null;
				arguments.add(C_k);
			}
			return new Function(f, arguments);
		}

		return null;
	}

	/**
	 * Builds a recurrent pair from the provided elements.
	 * 
	 * @param l1 the left-hand side of the rule R1
	 * @param r1 the right-hand side of the rule R1
	 * @param l2 the left-hand side of the rule R2
	 * @param r2 the right-hand side of the rule R2
	 * @param C the ground context C
	 * @param t the ground term t
	 * @param i the position of the increasing argument
	 * @param j the position of the decreasing argument
	 * @param nonterminating a non-terminating term
	 * generated by this recurrent pair
	 */
	private RecurrentPair(Function l1, Function r1, Function l2, Function r2,
			Term C, Term t, int i, int j, Function nonterminating) {

		this.l1 = l1;
		this.r1 = r1;
		this.l2 = l2;
		this.r2 = r2;
		this.C  = C;
		this.t  = t;
		this.i  = i;
		this.j  = j;
		this.nonterminating = nonterminating;
	}

	/**
	 * Returns a nonterminating term from this
	 * recurrent pair.
	 *  
	 * @return a nonterminating term
	 */
	public Function getNonTerminatingTerm() {
		return this.nonterminating;
	}

	/**
	 * Returns a string representation of this object.
	 * 
	 * @return a string representation of this object
	 */
	@Override
	public String toString() {
		return
				"Recurrent pair: < c = " + this.C +
				", t = " + this.t +
				", i = " + this.i +
				", j = " + this.j +
				", [" + this.l1 + " -> " + this.r1 +
				", " + this.l2 + " -> " + this.r2 + "] >";
	}
}
