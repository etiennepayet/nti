/*
 * Copyright 2022 Etienne Payet <etienne.payet at univ-reunion.fr>
 * 
 * This file is part of NTI.
 * 
 * NTI is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * NTI is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with NTI. If not, see <http://www.gnu.org/licenses/>.
 */

package fr.univreunion.nti.program;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;

import fr.univreunion.nti.term.Function;
import fr.univreunion.nti.term.FunctionSymbol;
import fr.univreunion.nti.term.Hole;
import fr.univreunion.nti.term.Term;

/**
 * A recurrent pair for proving the existence of a binary loop
 * (see Def. 3.12 of [Payet, JAR'23]).
 * 
 * @author <A HREF="mailto:etienne.payet@univ-reunion.fr">Etienne Payet</A>
 */

public class RecurrentPair {

	/**
	 * The left-hand side of the rule R1
	 * of this recurrent pair.
	 */
	private final Function l1;

	/**
	 * The right-hand side of the rule R1
	 * of this recurrent pair.
	 */
	private final Function r1;


	/**
	 * The left-hand side of the rule R2
	 * of this recurrent pair.
	 */
	private final Function l2;

	/**
	 * The right-hand side of the rule R2
	 * of this recurrent pair.
	 */
	private final Function r2;

	/**
	 * The ground context c of this recurrent pair.
	 */
	private final Term c;

	/**
	 * The ground term s of this recurrent pair.
	 */
	private final Term s;

	/**
	 * The term t of this recurrent pair
	 * (either equal to s or to a variable).
	 */
	private final Term t;

	/**
	 * The integers n1, n2, n3 of this recurrent pair.
	 */
	private final int n1, n2, n3, n4;

	/**
	 * The position of the increasing argument
	 * of this recurrent pair.
	 */
	private final int i;

	/**
	 * The position of the decreasing argument
	 * of this recurrent pair.
	 */
	private final int j;

	/**
	 * A non-terminating term generated by
	 * this recurrent pair.
	 */
	private final Function nonterminating;


	/**
	 * Static factory method. Tries to build a recurrent
	 * pair from the provided elements.
	 * 
	 * If a recurrent pair cannot be built then
	 * <code>null</code> is returned.
	 * 
	 * @param l the lhs of the first rule
	 * @param r the rhs of the first rule
	 * @param u the lhs of the second rule
	 * @param v the rhs of the second rule
	 * @return a recurrent pair, or <code>null</code>
	 */
	public synchronized static RecurrentPair getInstance(
			Function l, Term r, Function u, Term v) {

		if (r.isVariable() || v.isVariable() ||
				!r.hasSameStructureAs(u) ||
				!v.hasSameStructureAs(l))
			return null;

		boolean b1 = r.hasSameStructureAs(l);
		boolean b2 = v.hasSameStructureAs(u);

		if (!(b1 || b2)) return null;

		// Here, l, r, u and v necessarily have the form f(...)
		// for the same function symbol f.

		RecurrentPair result = null;
		if (b1)
			result = buildRecPair(l, (Function) r, u, (Function) v);
		if (result == null && b2)
			result = buildRecPair(u, (Function) v, l, (Function) r);

		return result;
	}

	/**
	 * Tries to build a recurrent pair from the
	 * provided elements. If a recurrent pair
	 * cannot be built then <code>null</code>
	 * is returned.
	 * 
	 * The provided terms necessarily have the
	 * form f(...) for the same function symbol f.
	 * 
	 * Moreover, <code>l1<code> unifies with a 
	 * renamed apart variant of <code>r1<code>,
	 * <code>r1<code> unifies with a renamed
	 * apart variant of <code>l2<code> and
	 * <code>r2<code> unifies with a 
	 * renamed apart variant of <code>l1<code>.
	 * 
	 * @param l1 the lhs of the rule R1 of the
	 * built recurrent pair
	 * @param r1 the rhs of the rule R1 of the
	 * built recurrent pair
	 * @param l2 the lhs of the rule R2 of the
	 * built recurrent pair
	 * @param r2 the rhs of the rule R2 of the
	 * built recurrent pair
	 * @return a recurrent pair, or <code>null</code>
	 */
	private synchronized static RecurrentPair buildRecPair(
			Function l1, Function r1, Function l2, Function r2) {

		// We flatten l1 and r1 (i.e., make each subterm the
		// only element of its class and be its own schema).
		Map<Term, Term> copies = new HashMap<Term, Term>();
		l1 = (Function) l1.deepCopy(copies);
		r1 = (Function) r1.deepCopy(copies);

		// We also flatten l2 and r2.
		copies = new HashMap<Term, Term>();
		l2 = (Function) l2.deepCopy(copies);
		r2 = (Function) r2.deepCopy(copies);

		// Here, l1, r1, l2 and r2 necessarily have the
		// form f(...) for the same function symbol f.

		// Now, we try to compute C, t, i and j.

		// The symbol f and its arity.
		FunctionSymbol f = l1.getRootSymbol();
		int n = f.getArity();

		// We identify the position i.
		for (int i = 0; i < n; i++) {
			// First, we check whether l1 = f(...,x1,...) and
			// l2 = f(...,x2,...) where x1 and x2 are variables
			// located at position i and occur only at that
			// position in l1, r1 and l2.
			Term x1 = l1.getChild(i), x2 = l2.getChild(i);
			if (x1.isVariable() && x2.isVariable() &&
					occursOnlyAt(x1, l1,  i, -1, n) &&
					occursOnlyAt(x1, r1, i, -1, n) &&
					occursOnlyAt(x2, l2,  i, -1, n)) {

				// We identify the position j.
				for (int j = 0; j < n; j++)
					if (j != i) {
						Term y1 = r1.getChild(j);
						Term s = l2.getChild(j);

						if (x1 != y1 && y1.isVariable() &&
								occursOnlyAt(y1, l1, -1, j, n) &&
								occursOnlyAt(y1, r1, -1, j, n) &&
								occursOnlyAt(x2, r2, i, j, n)  && 
								s.isGround()) {

							// 0x25A1 is the UFT-16 encoding of
							// the white square character.
							Hole square = new Hole("" + '\u25A1');
							Term c = groundContextFrom(l1.getChild(j), y1, square);

							if (c != null) {
								int n1 = towerOfContexts(r1.getChild(i), c, x1);
								// If c does not contain any hole then n1 < 0.
								if (0 <= n1) {
									Term t2 = r2.getChild(j);
									int n3 = towerOfContexts(t2, c, x2);
									if (0 <= n3) {
										Term t1 = r2.getChild(i);
										int n2 = towerOfContexts(t1, c, x2), n4 = 0;
										Term t = null, sCopy = s;
										if (0 <= n2) t = x2; // Here, n4 = 0 and we have already determined s.
										else {
											n2 = towerOfContexts(t1, c, s);
											if (0 <= n2) t = s; // Here, n4 = 0 and we have already determined s.
											else {
												n4 = towerOfContexts(s, c, t1);
												if (0 <= n4 && n4 <= n3) {
													n2 = 0;
													s = t1;
													t = t1;
												}
											}
										}
										if (t != null) {
											// We build the non-terminating term.

											// The arguments of the non-terminating term:
											LinkedList<Term> arguments = new LinkedList<Term>();
											for (int k = 0; k < n; k++)
												if (k == i) arguments.add(s);
												else if (k == j) arguments.add(sCopy);
												else {
													Term l1_k = l1.getChild(k);
													if (!(l1_k.unifyWith(r1.getChild(k)) &&
															l1_k.unifyWith(l2.getChild(k)) &&
															l1_k.unifyWith(r2.getChild(k))))
														// If a non-terminating term cannot be built
														// then we stop because another i or another j
														// will not work. Indeed, at that point, we have
														// l1_j = c[y] and r1_j = y, i.e., l1_j does not
														// unify with r1_j. We have something similar for i.
														return null;
													arguments.add(l1_k);
												}

											return new RecurrentPair(l1, r1, l2, r2,
													c, s, t, n1, n2, n3, n4,
													i, j, new Function(f, arguments));
										}
									}
								}
							}
						}
					}
			}
		}

		return null;
	}

	/**
	 * Checks whether the given term <code>x</code>
	 * occurs only at the given positions <code>i</code>
	 * and <code>j</code> of the given term <code>s</code>.
	 * 
	 * @param x a term whose presence is to be tested
	 * @param s a term where the check occurs
	 * @param i a position at which the presence is allowed
	 * @param j another position at which the presence is allowed
	 * @param n the arity of the function symbol of <code>s</code>
	 * @return <code>true</code> iff <code>x</code>
	 * occurs only at positions <code>i</code>
	 * and <code>j</code> of <code>s</code>
	 */
	private synchronized static boolean occursOnlyAt(
			Term x, Function s, int i, int j, int n) {

		for (int k = 0; k < n; k++)
			if (k != i && k != j && s.getChild(k).contains(x))
				return false;

		return true;
	}

	/**
	 * Checks whether <code>c_y = c[y]</code> for a
	 * ground context <code>c</code> (that possibly
	 * contains several occurrences of the provided
	 * hole).
	 * 
	 * BEWARE: the returned c may not contain 
	 * the provided hole. This happens when
	 * <code>c_y</code> is a ground function
	 * that does not contain <code>y</code>.
	 * 
	 * @param c_y the outer term from which a
	 * context is built
	 * @param y the inner term from which a
	 * context is built (supposed to be a variable)
	 * @param square the hole to be used while
	 * building the context
	 * @return a ground context, or <code>null</code>
	 * if no context could be built from the provided
	 * terms
	 */
	private synchronized static Term groundContextFrom(
			Term c_y, Term y, Hole square) {

		if (c_y.isVariable())
			// y is supposed to be a variable, hence the
			// use of ==.
			return (c_y == y ? square : null);

		if (c_y instanceof Function) {
			FunctionSymbol f = c_y.getRootSymbol();
			int n = f.getArity();
			LinkedList<Term> arguments = new LinkedList<Term>();
			for (int k = 0; k < n; k++) {
				Term c_k;
				if ((c_k = groundContextFrom(c_y.get(k), y, square)) == null)
					return null;
				arguments.add(c_k);
			}
			return new Function(f, arguments);
		}

		return null;
	}

	/**
	 * Checks whether the provided term <code>t</code> has the
	 * form <code>c^n[base]</code> for some <code>n</code>.
	 * If so, then returns <code>n</code>. Otherwise, returns
	 * a negative integer.
	 * 
	 * In particular, a negative integer is returned if
	 * <code>c</code> does not contain any hole.
	 * 
	 * @param t a term to be checked
	 * @param c a context (possibly with several holes)
	 * @param base a base term
	 * @return <code>n</code> if it exists, otherwise a
	 * negative integer
	 */
	private synchronized static int towerOfContexts(Term t, Term c, Term base) {		
		// If t is equal to base, then it is equal to c^0[base].
		if (t.deepEquals(base)) return 0;

		FunctionSymbol f = t.getRootSymbol();
		if (f == c.getRootSymbol()) {
			Term c_k;
			int n = f.getArity();
			int tow = -2;
			for (int k = 0; k < n; k++)
				if ((c_k = c.get(k)) instanceof Hole) {
					int tow_k;
					if ((tow_k = towerOfContexts(t.get(k), c, base)) < 0)
						return -1;
					// If this is the first instance of a hole
					// we encounter, then we set tow to tow_k.
					if (tow < 0) tow = tow_k;
					// Otherwise, we check whether tow_k is
					// equal to the value obtained with the
					// previous holes.
					else if (tow != tow_k) return -1;
				}
				else if (!c_k.deepEquals(t.get(k)))
					return -1;
			return tow + 1;
		}

		return -1;
	}

	/**
	 * Builds a recurrent pair from the provided elements.
	 * 
	 * @param l1 the left-hand side of the rule R1
	 * @param r1 the right-hand side of the rule R1
	 * @param l2 the left-hand side of the rule R2
	 * @param r2 the right-hand side of the rule R2
	 * @param c the ground context c
	 * @param s the ground term s
	 * @param t the term t
	 * @param n1 the integer n1
	 * @param n2 the integer n2
	 * @param n3 the integer n3
	 * @param i the position of the increasing argument
	 * @param j the position of the decreasing argument
	 * @param nonterminating a non-terminating term
	 * generated by this recurrent pair
	 */
	private RecurrentPair(Function l1, Function r1, Function l2, Function r2,
			Term c, Term s, Term t, int n1, int n2, int n3, int n4,
			int i, int j, Function nonterminating) {

		this.l1 = l1;
		this.r1 = r1;
		this.l2 = l2;
		this.r2 = r2;
		this.c  = c;
		this.s  = s;
		this.t  = t;
		this.n1 = n1;
		this.n2 = n2;
		this.n3 = n3;
		this.n4 = n4;
		this.i  = i;
		this.j  = j;
		this.nonterminating = nonterminating;
	}

	/**
	 * Returns the left-hand side of the rule R1
	 * of this recurrent pair.
	 */
	public Function getLeft1() {
		return this.l1;
	}

	/**
	 * Returns the right-hand side of the rule R1
	 * of this recurrent pair.
	 */
	public Function getRight1() {
		return this.r1;
	}

	/**
	 * Returns the left-hand side of the rule R2
	 * of this recurrent pair.
	 */
	public Function getLeft2() {
		return this.l2;
	}

	/**
	 * Returns the right-hand side of the rule R2
	 * of this recurrent pair.
	 */
	public Function getRight2() {
		return this.r2;
	}

	/**
	 * Returns the context c
	 * of this recurrent pair.
	 */
	public Term getContext() {
		return this.c;
	}

	/**
	 * Returns the ground term s of
	 * this recurrent pair.
	 */
	public Term getS() {
		return this.s;
	}

	/**
	 * Returns the term t of
	 * this recurrent pair.
	 */
	public Term getT() {
		return this.t;
	}

	/**
	 * Returns the integer n1 of
	 * this recurrent pair.
	 */
	public int getN1() {
		return this.n1;
	}

	/**
	 * Returns the integer n2 of
	 * this recurrent pair.
	 */
	public int getN2() {
		return this.n2;
	}

	/**
	 * Returns the integer n3 of
	 * this recurrent pair.
	 */
	public int getN3() {
		return this.n3;
	}

	/**
	 * Returns the integer n4 of
	 * this recurrent pair.
	 */
	public int getN4() {
		return this.n4;
	}

	/**
	 * Returns the position i of
	 * this recurrent pair.
	 */
	public int getI() {
		return this.i;
	}

	/**
	 * Returns the position j of
	 * this recurrent pair.
	 */
	public int getJ() {
		return this.j;
	}

	/**
	 * Returns a nonterminating term from this
	 * recurrent pair.
	 *  
	 * @return a nonterminating term
	 */
	public Function getNonTerminatingTerm() {
		return this.nonterminating;
	}
}
